plot(ltt.measure , type="l")
order(ltt.times) == (1:(length(ltt.times)))
any(!order(ltt.times) == (1:(length(ltt.times))))
tree.object$vtt <- vtt.measure#
		tree.object$ltt <- ltt.measure
phy <- tree.object$phy	#
		extant.phy <- drop.fossil(phy)#
		lost.tips <- which(is.na(match(phy$tip.label, extant.phy$tip.label)))#
		if (length(lost.tips) > 0) {#
			tip.loc <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.go <- tip.loc[lost.tips]#
			int.nodes <- unique(phy$edge[,1])[-1]#
			match.int <- sapply(int.nodes, function(x) {#
				int.des <- node.descendents(x, phy, T)[[2]]#
				any(match(extant.phy$tip.label, int.des))#
				}#
			)#
			node.tip.to.go <- tip.to.go#
			node.extinct <- which(is.na(match.int))	#
			if(length(node.extinct) > 0) {#
				int.to.go <- int.nodes[node.extinct]#
				for(x in 1:length(int.to.go)) node.tip.to.go <- c(node.tip.to.go, which(int.to.go[x] ==  phy$edge[,2]))#
				}#
			time.ltt <- unlist(time.list[re.order][-node.tip.to.go])#
			branch.entries <- unlist(branch.value.list[re.order][-node.tip.to.go])#
		} else {#
			time.ltt <- unlist(time.list[re.order])#
			branch.entries <- unlist(branch.value.list[re.order])#
		}
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)
ltt.times.sort
tab.time.ltt <- tab.time.ltt[ltt.times.sort]
ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))
ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)
plot(ltt.measure.extant, type="l")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		# tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)
plot(ltt.measure.extant, type="l")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)
plot(	ltt.measure.extant, type="l")
plot(	ltt.measure.extant, type="s")
lines(ltt.plot.coords(extant.phy, F))
lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
lines(ltt.plot.coords(extant.phy, F), type="s", col="red") + 2
lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)
ltt.measure.extant
ltt.plot.coords(extant.phy, F)
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] )#- re.scale)#
		plot(	ltt.measure.extant, type="s")
lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(0, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)#
		plot(	ltt.measure.extant, type="s")#
		lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(-1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)#
		plot(	ltt.measure.extant, type="s")#
		lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		#tab.time.ltt <- tab.time.ltt[ltt.times.sort]#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)#
		plot(	ltt.measure.extant, type="s")#
		lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
dev.new()
plot(ladderize(extant.phy))
ltt.measure.extant
match(unique(tab.time.ltt )
match(unique(tab.time.ltt ), tab.time.ltt )
tab.time.ltt <- table(signif(time.ltt, 20))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		ltt.times.sort <- order(tab.time.ltt)#
		# tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure.extant <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)#
		plot(	ltt.measure.extant, type="s")
lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
#
	while (any(c(length(open.edges) < (extant.tips + 1), mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			set.seed(as.numeric(Sys.time()))	#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- free.edges.values[,trait.axes] # user-selected traits#
				if (length(trait.axes) == 1) trait.sel <- t(trait.sel)#
				} else {#
				trait.sel <- free.edges.values # all traits#
				}#
			if (larger.than) {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))#
				} else {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))	#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	tree.object$branch.value.list.out <- branch.value.list[re.order]#
	tree.object$time.list.out <- time.list[re.order]#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time
time.ltt <- unlist(time.list[re.order])
tab.time.ltt <- table(signif(time.ltt, 10))
ltt.times <- as.numeric(names(tab.time.ltt))
any(!order(ltt.times) == (1:(length(ltt.times))))
time.ltt <- unlist(time.list[re.order])#
		tab.time.ltt <- table(signif(time.ltt, 10))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)#
		branch.entries <- unlist(branch.value.list[re.order])
plot(	ltt.measure.extant, type="s")#
		lines(ltt.plot.coords(extant.phy, F), type="s", col="red")
plot(	ltt.measure.extant, type="s")#
		lines(ltt.plot.coords(phy, F), type="s", col="red")
plot(	ltt.measure, type="s")
lines(ltt.plot.coords(phy, F), type="s", col="red")
time.ltt <- unlist(time.list[re.order])#
		tab.time.ltt <- table(signif(time.ltt, 10))#
		ltt.times <- as.numeric(names(tab.time.ltt))#
		# tab.time.ltt <- tab.time.ltt[match(unique(tab.time.ltt ), tab.time.ltt )]#
		tot.ln <- length(ltt.times)#
		re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
		ltt.measure <- cbind("node.times"=ltt.times[-tot.ln], "lineages"=as.numeric(tab.time.ltt)[-tot.ln] - re.scale)
plot(	ltt.measure, type="s")#
		lines(ltt.plot.coords(phy, F), type="s", col="red")
rexp()
54 ^ -93
54 ^ -33
54 ^ -0.1
1 ^ -0.1
1 ^ -02.1
1:8
rr <- 1:10
rr ^ 2
rr ^ -2
ext.chance <- rr ^ 2
ext.chance / sum(ext.chance)
rm(list=ls(all=T))#
library(RSOLE)
ext.rate=0
nt=50
data.in <- dget(paste0("~/Documents/disparitySimulation/simple_models/output/centroid/centroid.tips_", nt, ".lambda_1.mu_", ext.rate, ".sigma_1.txt"))
time.scale.full <- unlist(lapply(data.in, function(x) x$vtt[,1]))
diff.full <- unlist(lapply(data.in, function(x) x$vtt[,2] - x$ltt[,2]))#
		ord.time <- order(time.scale.full)#
		time.scale.full <- time.scale.full[ord.time]#
		diff.full <- diff.full[ord.time]#
		# plot(time.scale.full, diff.full, ylim=c(-1, 1), col="#00008001", pch=19, yaxt="n", xlab="", ylab="", las=1, xaxt="n")#
		bin.breaks <- seq(0,1, 0.1)#
		inbins <- .bincode(time.scale.full, bin.breaks, include.lowest=T)
boxplot(diff.full ~ inbins, labels=F, xaxt="n", yaxt="n", range=0, col="grey", border="grey50", ylim=c(-1, 1))
if(nt == 50) {#
			axis(2, las=1, at=c(seq(-0.8, 0.8, 0.2)))#
			if(ext.rate == 0.5) mtext("relative diversity and disparity", 2, cex=0.7, at=1, line=2.5)#
		}
if(ext.rate == 0.9) {#
			if(nt == 100) mtext("time", 1, cex=0.7, at=1, line=2.5)#
			axis(1, labels=c(0.2, 0.4, 0.6, 0.8, 1.0), at=c(2,4,6,8, 10))#
			}#
		if(ext.rate == 0) mtext(paste0("extant tips ", nt), 3, cex=0.7)
model.linear <- lm(diff.full ~ time.scale.full)#
		model.sq <- lm(diff.full ~ poly(time.scale.full, 2))#
		model.cube <- lm(diff.full ~ poly(time.scale.full, 3))#
		AIC.linear <- AIC(model.linear)#
		AIC.sq <- AIC(model.sq)#
		AIC.cube <- AIC(model.cube)#
		min.aic <- which.min(c(AIC.linear, AIC.sq, AIC.cube))#
		if (min.aic == 1) pred.model <- predict(model.linear, seq(0, 1, 0.1), interval="confidence", level=0.99)#
		if (min.aic == 2) pred.model <- predict(model.sq, data.frame(x = re.all.x), interval="confidence", level=0.99)#
		if (min.aic == 3) pred.model <- predict(model.cube, x = seq(0, 1, 0.1), interval="confidence", level=0.99)#
		# abline(h=0, lty=2, col="grey50", lwd=1)#
		lines(time.scale.full * length(bin.breaks), pred.model[,1], col="#00000050", lwd=2)#
		lines(time.scale.full * length(bin.breaks), pred.model[,2], col="#00000050", lwd=1)#
		lines(time.scale.full * length(bin.breaks), pred.model[,3], col="#00000050", lwd=1)
data.in <- dget(paste0("~/Documents/disparitySimulation/simple_models/output/centroid/centroid.tips_", nt, ".lambda_1.mu_", ext.rate, ".sigma_1.txt"))
time.scale.full <- unlist(lapply(data.in, function(x) x$vtt[,1]))
diff.full <- unlist(lapply(data.in, function(x) x$vtt[,2] - x$ltt[,2]))#
		ord.time <- order(time.scale.full)#
		time.scale.full <- time.scale.full[ord.time]#
		diff.full <- diff.full[ord.time]#
		bin.breaks <- seq(0,1, 0.1)#
		inbins <- .bincode(time.scale.full, bin.breaks, include.lowest=T)#
		boxplot(diff.full ~ inbins, labels=F, xaxt="n", yaxt="n", range=0, col="grey", border="grey50", ylim=c(-1, 1))
if(nt == 50) {#
			axis(2, las=1, at=c(seq(-0.8, 0.8, 0.2)))#
			if(ext.rate == 0.5) mtext("relative diversity and disparity", 2, cex=0.7, at=1, line=2.5)#
		}
data.in <- dget(paste0("~/Documents/disparitySimulation/simple_models/output/centroid/centroid.tips_", nt, ".lambda_1.mu_", ext.rate, ".sigma_1.txt"))#
#
		time.scale.full <- unlist(lapply(data.in, function(x) x$vtt[,1]))	#
		diff.full <- unlist(lapply(data.in, function(x) x$vtt[,2] - x$ltt[,2]))#
		ord.time <- order(time.scale.full)#
		time.scale.full <- time.scale.full[ord.time]#
		diff.full <- diff.full[ord.time]#
		bin.breaks <- seq(0,1, 0.1)#
		inbins <- .bincode(time.scale.full, bin.breaks, include.lowest=T)#
		boxplot(diff.full ~ inbins, labels=F, xaxt="n", yaxt="n", range=0, col="grey", border="grey50", ylim=c(-1, 1))#
		if(nt == 50) {#
			axis(2, las=1, at=c(seq(-0.8, 0.8, 0.2)))#
			if(ext.rate == 0.5) mtext("relative diversity and disparity", 2, cex=0.7, at=1, line=2.5)#
		}
if(ext.rate == 0.9) {#
			if(nt == 100) mtext("time", 1, cex=0.7, at=1, line=2.5)#
			axis(1, labels=c(0.2, 0.4, 0.6, 0.8, 1.0), at=c(2,4,6,8, 10))#
			}#
		if(ext.rate == 0) mtext(paste0("extant tips ", nt), 3, cex=0.7)
model.linear <- lm(diff.full ~ time.scale.full)#
		model.sq <- lm(diff.full ~ poly(time.scale.full, 2))#
		model.cube <- lm(diff.full ~ poly(time.scale.full, 3))#
		AIC.linear <- AIC(model.linear)#
		AIC.sq <- AIC(model.sq)#
		AIC.cube <- AIC(model.cube)#
		min.aic <- which.min(c(AIC.linear, AIC.sq, AIC.cube))
if (min.aic == 1) pred.model <- predict(model.linear, seq(0, 1, 0.1), interval="confidence", level=0.99)
min.aic == 2
time.scale.full
pred.model <- predict(model.sq, data.frame(x = unique(time.scale.full)), interval="confidence", level=0.99)
unique(time.scale.full)
model.sq
pred.model <- predict(model.sq, data.frame(x = time.scale.full), interval="confidence", level=0.99)
lines(time.scale.full * length(bin.breaks), pred.model[,1], col="#00000050", lwd=2)#
		lines(time.scale.full * length(bin.breaks), pred.model[,2], col="#00000050", lwd=1)#
		lines(time.scale.full * length(bin.breaks), pred.model[,3], col="#00000050", lwd=1)
pred.model <- predict(model.sq, seq(0, 1, 0.1), interval="confidence", level=0.99)
par(mfrow=c(6,6), mar=c(0,0,0,0), oma=c(4,4,4,4))#
#
for(ext.rate in c(0, 0.1, 0.3, 0.5, 0.7, 0.9)) {#
	for(nt in c(50, 100, 200, 250)) {#
		data.in <- dget(paste0("~/Documents/disparitySimulation/simple_models/output/centroid/centroid.tips_", nt, ".lambda_1.mu_", ext.rate, ".sigma_1.txt"))#
#
		time.scale.full <- unlist(lapply(data.in, function(x) x$vtt[,1]))	#
		diff.full <- unlist(lapply(data.in, function(x) x$vtt[,2] - x$ltt[,2]))#
		ord.time <- order(time.scale.full)#
		time.scale.full <- time.scale.full[ord.time]#
		diff.full <- diff.full[ord.time]#
		bin.breaks <- seq(0,1, 0.1)#
		inbins <- .bincode(time.scale.full, bin.breaks, include.lowest=T)#
		boxplot(diff.full ~ inbins, labels=F, xaxt="n", yaxt="n", range=0, col="grey", border="grey50", ylim=c(-1, 1))#
		if(nt == 50) {#
			axis(2, las=1, at=c(seq(-0.8, 0.8, 0.2)))#
			if(ext.rate == 0.5) mtext("relative diversity and disparity", 2, cex=0.7, at=1, line=2.5)#
		}		#
		if(ext.rate == 0.9) {#
			if(nt == 100) mtext("time", 1, cex=0.7, at=1, line=2.5)#
			axis(1, labels=c(0.2, 0.4, 0.6, 0.8, 1.0), at=c(2,4,6,8, 10))#
			}#
		if(ext.rate == 0) mtext(paste0("extant tips ", nt), 3, cex=0.7)#
		model.linear <- lm(diff.full ~ time.scale.full)#
		model.sq <- lm(diff.full ~ poly(time.scale.full, 2))#
		model.cube <- lm(diff.full ~ poly(time.scale.full, 3))#
		AIC.linear <- AIC(model.linear)#
		AIC.sq <- AIC(model.sq)#
		AIC.cube <- AIC(model.cube)#
		min.aic <- which.min(c(AIC.linear, AIC.sq, AIC.cube))#
		if (min.aic == 1) pred.model <- predict(model.linear, data.frame(x = time.scale.full), interval="confidence", level=0.99)#
		if (min.aic == 2) pred.model <- predict(model.sq, data.frame(x = time.scale.full), interval="confidence", level=0.99)#
		if (min.aic == 3) pred.model <- predict(model.cube, x = data.frame(x = time.scale.full), interval="confidence", level=0.99)#
		lines(time.scale.full * length(bin.breaks), pred.model[,1], col="#00000050", lwd=2)#
		lines(time.scale.full * length(bin.breaks), pred.model[,2], col="#00000050", lwd=1)#
		lines(time.scale.full * length(bin.breaks), pred.model[,3], col="#00000050", lwd=1)#
	}#
	mtext(paste0("mu ", ext.rate), 4, line=1, cex=0.7)#
	for(u in 1:2) plot(NA, NA, xlim=c(0,1), ylim=c(0,1), xaxt="n", yaxt="n", bty="n", xlab="", ylab="")#
}
lambda=1; mu=0; extant.tips=100; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if (larger.than) {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))#
				} else {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))	#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
library(MASS)
library(ape)
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if (larger.than) {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))#
				} else {#
				ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
				ext.casualty <- unique(c(ext.casualty))	#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))
free.edges.values
if(n.characters == 1) free.edges.values <- t(free.edges.values)
free.edges.values
hist(free.edges.values)
mean(free.edges.values)
hist(free.edges.values)
abline(v=mean(free.edges.values))
free.edges.values
branch.value.list
branch.value.list[open.edges]
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))
if(n.characters == 1) free.edges.values <- t(free.edges.values)
abline(v=mean(free.edges.values))
hist(free.edges.values)
mean(free.edges.values)
sort(free.edges.values)
length(free.edges.values)
sort(free.edges.values)
ceiling(free.edges.values) / 2
ceiling(length(free.edges.values) / 2)
summary(free.edge.values)
free.edges.values
summary(free.edge.values)
summary(free.edge.values[,1])
summary(free.edges.values[,1])
trait.sel <- as.matrix(free.edges.values) # all traits
trait.sel
ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))
ext.casualty
x
mass.ext.quantile
x.mean <- 0.2
ext.casualty <- apply(trait.sel, 2, function(x) {#
				intersect(which(x >= quantile(x, x.mean)), which(x <= quantile(x, (1-x.mean))))#
				}
)
ext.casualty
mass.ext.quantile
mass.ext.quantile <- mass.ext.quantile / 2
mass.ext.quantile
intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))
ext.casualty <- apply(trait.sel, 2, function(x) {#
				intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
				})
ext.casualty
mass.ext.quantile=.4
mass.ext.quantile=.9
mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)
ext.casualty
mass.ext.quantile
ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}
ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile)), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}
mass.ext.quantile
mass.ext.quantile=0.9
mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile)), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)
ext.casualty
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			hist(free.edges.values)#
			abline(v=mean(free.edges.values))#
			all.values <- length(free.edges.values)#
			summary(free.edges.values[,1])#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile)), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			hist(free.edges.values)#
			abline(v=mean(free.edges.values))#
			all.values <- length(free.edges.values)
summary(free.edges.values[,1])
# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}
mass.ext.quantile <- mass.ext.quantile / 2
mass.ext.quantile
ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile)), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)
ext.casualty
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					c(which(x <= quantile(x, mass.ext.quantile)), which(x > quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}
length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
library(MASS)
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
which(sapply(branch.value.list, function(x) dim(x)[1] == 1))
zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}
zero.length
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))
free.edges.values
tips <- length(which(start.edge[ ,2] == 0))#
		n.tips.t <- tips#
		if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
		open.edges <- which(is.na(start.edge[,2]))
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))
free.edges.values
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
mass.ext.occ
length(open.edges)
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}
zero.length
tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))
pen.edges
open.edges
free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))
free.edges.values
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
build.tree.tips(lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE)
build.tree.tips(lambda=1, mu=0, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)
lambda=1; mu=0; extant.tips=50; mass.ext.tips=50; mass.ext.quantile=0.5; n.characters=1; sigma.rates=1; spp.size.prob=0; ext.size.prob=0; larger.than=TRUE; both.sides=FALSE; mass.ext.occ=TRUE; mass.ext.severity=0.5; trait.axes = NULL; chance.of.random = 0.1; upperBound=Inf; lowerBound=-Inf; return.trait.matrix=TRUE; return.branch.value.list=FALSE; return.time.list=FALSE
tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}
zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))
zero.length
if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}
# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)
# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")
# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}
# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]
for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]
phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]
library(ape)
phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 2) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
build.tree.tips(lambda=1, mu=0, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)
tr.out <- build.tree.tips(lambda=1, mu=0, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)
tr.out[[1]]
plot(tr.out[[1]])
plot(tr.out[[1]], cex=0.2)
plot(tr.out[[1]], cex=0.6)
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips + 1#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) < extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips + 1) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
			if (length(zero.length) == 2) {#
				start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
				start.edge <- start.edge[-zero.length, ]#
				branch.value.list <- branch.value.list[-zero.length]#
				edge.lengths <- edge.lengths[-zero.length]#
				}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				# warning("mass extinction trait selectivity destroyed all lineages - extinction selectivity randomised to allow tree to exist")#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
tr.out <- build.tree.tips(lambda=1, mu=0, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)
plot(tr.out[[1]], cex=0.6)
tr.out[[1]]
tr.out <- build.tree.tips(lambda=1, mu=0, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)#
plot(tr.out[[1]], cex=0.6)
tr.out <- build.tree.tips(lambda=1, mu=0.2, extant.tips=50, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)
tr.out
tr.out[[1]]
plot(tr.out[[1]], cex=0.6)
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	#if (mass.ext.occ) {#
		#	extant.tips.target <- extant.tips#
		#} else {#
			extant.tips.target <- extant.tips#
		#}#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) != extant.tips.target, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			N <- length(open.edges)#
			waiting.time <- rexp(1, N * (lambda + mu))#
			total.time <- total.time + waiting.time#
			edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
			branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
					}#
			rbind(branch.vals, branch.vals.temp)#
				}#
			)	#
			time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
	N <- length(open.edges)#
	waiting.time <- rexp(1, N * (lambda + mu))#
	total.time <- total.time + waiting.time#
	edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
	branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
	last.time <- branch.vals[dim(branch.vals)[1], ]#
	withinBounds <- FALSE#
	while (withinBounds == FALSE) {#
		branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
		if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
			}#
	rbind(branch.vals, branch.vals.temp)#
		}#
	)	#
	time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
	# remove zero length edges#
	zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	if (length(zero.length) == 2) {#
		start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		start.edge <- start.edge[-zero.length, ]#
		branch.value.list <- branch.value.list[-zero.length]#
		edge.lengths <- edge.lengths[-zero.length]#
		}#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
library(MASS)
library(ape)
tr <- build.tree.tips()
tr
tr[[1]]
tr <- build.tree.tips(mass.ext.occ=F)
tr[[1]]
duplicated(tr[[1]]$tip.label)
unique(tr[[1]]$tip.label)
names(tr)
tr[[3]]
tr[[3]][which(tr[[1]]$edge[,2] <= 100)]
tr[[3]][[1]][which(tr[[1]]$edge[,2] <= 100)]
tr[[1]]
trait.data <- tr[[3]][[1]][which(tr[[1]]$edge[,2] <= 100)]
table(trait.data)
trait.data <- tr[[3]][[1]][which(tr[[1]]$edge[,2] <= 100), 2]
trait.data
table(trait.data)
max(table(trait.data))
library(motmot.2.0)
y <- as.matrix(trait.data)
rownames(y) <- tr[[1]]$tip.label
transformPhylo.ML(y=y, phy=tr[[1]], model="lambda")
transformPhylo.ML(y=y, phy=tr[[1]], model="bm")
transformPhylo.ML(y=y, phy=tr[[1]], model="ACDC")
#' @title Simulate simultaneously phylogeny and trait evolution#
#' @description Simulates a birth-death phylogeny with simultaneous evolution under Brownian motion for one or more traits. The simulations continue until a user-set number of tips are sampled. Additionaly, a mass extinction can occur with a user-set intensity of extinction when a certain number of species are present. Traits can be correlated or independent, can be linked to increased rates of speciation and/or extinction at background times, and can drive selectivity at mass extinction event. #
#' @param lambda Speciation rate#
#' @param mu Extinction rate. If mu=0, then the simulation follows a Yule pure birth process#
#' @param extant.tips The number of extant lineages with which to end the simulation. Must be > 0.#
#' @param mass.ext.tips The numebr of extant lineages to reach before a mass extinction. Not applicable if mass.ext.occ=FALSE#
#' @param mass.ext.severity the proportion of lineages that succumb to extinction, not applicable if mass.ext.occ=FALSE#
#' @param n.characters the number of trait characters to simulate under a Brownian motion process#
#' @param sigma.rates Either a vector or matrix specifying the rates of character evolution. If a vector then all traits evolve independently, and values are recylced if the length is less than n.characters. If a square matrix, this specifies the relative rates (diagonals) and correlation between traits (off-diagonals)#
#' @param spp.size.prob Probability of lineages with smaller trait values splitting during 'background' times. If the value is 0 then all lineages have an equal probability of splitting; larger values mean lineages with smaller trait values are more likely to split, and values < 0 mean lineages with larger trait values are more likely to split#
#' @param ext.size.prob Probability of lineages with larger trait values going extinct during 'background' times. If the value is 0 then all lineages have an equal probability of extinction; larger values mean lineages with larger trait values are more likely to go extinct, and values < 0 mean lineages with smaller trait valyes are more likely to go extinct#
#' @param mass.ext.occ Logical specifying if a mass extinction occurs at the time given by time.limit.mass.ext (default = TRUE). #
#' @param mass.ext.quantile The cut-off for the trait values selected for extinction during the mass extinction event. Values above mass.ext.quantile will be marked for loss during the mass extinction event. #
#' @param chance.of.random Numeric. A value to specify the 'selectivity' of extinction. If chance.of.random=0 only lineages with trait values above or below the limit specified by mass.ext.quantile will go extinct. Values > 0 and < 1 indicate the trait is selected for with decreasing strength, until chance.of.random = 1 at which point all lineages are equally likely to go extinct#
#' @param larger.than Logical. If TRUE, then mass extinction selection occurs on traits larger than the proportion indicated by 'mass.ext.quantile'. If FALSE, the smaller traits are selected for extinction#
#' @param both.sides Logical. If TRUE, then mass extinction selection occurs on at the extreme ends of trait distribution. NOTE - this over-rides the argument 'larger than' so default is FALSE.#
#' @param trait.axes The trait axes on which selection will occur. The default (NULL) acts on all trait axes#
#' @param return.trait.matrix Logical. If TRUE the values at internal and external nodes is returned in a matrix corresponding to the APE phylo edge format#
#' @param return.branch.value.list Logical. Returns a list with all trait values at every time point. Default is FALSE as TRUE can results in huge files#
#' @param return.time.list Logical. Returns a list with every time points at which the simulation ran. Default is FALSE as TRUE can results in huge files#
#' @param upperBound The upper bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (Inf)#
#' @param lowerBound The lower bound allowed for trait values. Trait space can be constrained by specifying a value rather than then default (-Inf)#
#' @return A list containing:#
#' \itemize{#
#' \item {phy} {The output phylogeny}#
#' \item {root.state} {value(s) for trait(s) at the root}#
#' \item {trait.matrix} {List of trait values at all internal nodes and tips on the phylogeny. If n.characters > 1, then there are list entries for each trait value}#
#' \item {branch.value.list.out} {The value of traits at each time unit in the simulation. Each list element corresponds to the edge in the phy$edge matrix, and the time given by time.list.out}#
#' \item {vtt} {The variance measured at each node of the phylogeny to give 'variance-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {ltt} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data. Only returned if return.through.time=TRUE}#
#' \item {vtt.extant} {The variance measured at each node of the phylogeny to give 'variance-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' \item {ltt.extant} {The number of lineages measured at each node of the phylogeny to give 'lineage-through-time' data based on lineages that survive to present only. Only returned if return.through.time.extant=TRUE}#
#' }#
#' @author Mark Puttick#
#' @import ape#
#' @import MASS#
#' @import motmot.2.0#
#' @export#
#
build.tree.tips <- function(lambda=1, mu=0, extant.tips=100, mass.ext.tips=50, mass.ext.quantile=0.5, n.characters=1, sigma.rates=1, spp.size.prob=0, ext.size.prob=0, larger.than=TRUE, both.sides=FALSE, mass.ext.occ=TRUE, mass.ext.severity=0.5, trait.axes = NULL, chance.of.random = 0.1, upperBound=Inf, lowerBound=-Inf, return.trait.matrix=TRUE, return.branch.value.list=FALSE, return.time.list=FALSE)  {#
#
	tree.alive <- FALSE#
	total.time <- 0#
	open.edges <- 2#
	mass.ext.occ.input <- mass.ext.occ#
	if (lambda < 1e-8) stop("speciation rates must be greater than zero")#
	# starting parameters for BM process#
	if(!is.matrix(sigma.rates)) {#
		bm.rates <- diag(sigma.rates, n.characters , n.characters )#
		} else {#
		bm.rates <- sigma.rates#
	}#
	while (any(c(length(open.edges) != extant.tips, mass.ext.occ))) {#
#
		if(tree.alive == FALSE) {#
			# starting parameters for birth-death process#
			start.edge <- matrix(c(1, 1, NA, NA), 2, 2)#
			edge.length.list <- branch.value.list <- time.list <- list()#
			open.edges <- which(is.na(start.edge[,2]))#
			edge.lengths <- c(0, 0)#
			n.tips <- total.time <- 0#
			root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)	#
			withinBounds <- FALSE#
			if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			while (withinBounds == FALSE) {#
				root.state <- mvrnorm(n=1, mu=rep(0, n.characters), Sigma=bm.rates)#
				if (all(c(root.state <= upperBound, root.state >= lowerBound))) withinBounds <- TRUE#
			}#
			branch.value.list[[1]] <- branch.value.list[[2]] <- rbind(root.state)#
			time.list[[1]] <- time.list[[2]] <- total.time#
			tree.alive <- TRUE#
			mass.ext.occ <- mass.ext.occ.input#
		}#
#
		N <- length(open.edges)#
		waiting.time <- rexp(1, N * (lambda + mu))#
		uniform.dist <- runif(1, 0, 1)#
		prop.lambda <- lambda / (lambda + mu)#
		total.time <- total.time + waiting.time#
		spp.or.ext <- uniform.dist <= prop.lambda#
		edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
		branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
				}#
			rbind(branch.vals, branch.vals.temp)#
			}#
		)	#
		time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
		n.tips <- length(which(start.edge[,2] > 0))#
		if (spp.or.ext) {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			spp.value.order <- order(free.edges.values)#
			spp.chance <- spp.value.order ^ spp.size.prob#
			prob.of.spp <- spp.chance / sum(spp.chance)#
			spp.edge <- sample(1:length(open.edges), 1, prob=prob.of.spp)#
			new.label <- max(start.edge, na.rm = T) + 1#
			start.edge[open.edges[spp.edge] , 2] <- new.label#
			start.edge <- rbind(start.edge, matrix(c(new.label, new.label, NA, NA), 2, 2))#
			edge.lengths <- c(edge.lengths, 0, 0)#
			node.temp <- tail(branch.value.list[[open.edges[spp.edge]]], 1)#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			branch.value.list[[length(branch.value.list) + 1]] <- node.temp#
			time.list[[length(time.list) + 1]] <- total.time#
			time.list[[length(time.list) + 1]] <- total.time #
			} else {#
			free.edges.values <- sapply(branch.value.list[open.edges], function(x) x[dim(x)[1]])#
			ext.risk.order <- order(free.edges.values)#
			ext.chance <- ext.risk.order ^ ext.size.prob		#
			prob.of.ext <- ext.chance / sum(ext.chance)#
			ext.edge <- sample(1:length(open.edges), 1, prob = prob.of.ext)#
			start.edge[open.edges[ext.edge] , 2] <- 0#
		}#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE#
			open.edges <- which(is.na(start.edge[,2]))#
		if (length(open.edges) == (mass.ext.tips) && mass.ext.occ) {#
			# stop()#
			# lineages alive at mass extinction occurrence#
			N <- length(open.edges)#
			waiting.time <- rexp(1, N * (lambda + mu))#
			total.time <- total.time + waiting.time#
			edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
			branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
			last.time <- branch.vals[dim(branch.vals)[1], ]#
			withinBounds <- FALSE#
			while (withinBounds == FALSE) {#
				branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
				if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
					}#
			rbind(branch.vals, branch.vals.temp)#
				}#
			)	#
			time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
			free.edges.values <- t(sapply(branch.value.list[open.edges], function(x) x[dim(x)[1], ]))#
			if(n.characters == 1) free.edges.values <- t(free.edges.values)#
			# if extinction is selective, choose lineages according to their 'trait' values#
			if(! is.null(trait.axes)) {#
				trait.sel <- as.matrix(free.edges.values[,trait.axes]) # user-selected traits#
			} else {#
				trait.sel <- as.matrix(free.edges.values) # all traits#
			}#
			if(both.sides == FALSE) {#
				if (larger.than) {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x >= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))#
					} else {#
					ext.casualty <- apply(trait.sel, 2, function(x) which(x <= quantile(x, mass.ext.quantile)))#
					ext.casualty <- unique(c(ext.casualty))	#
				}#
			} else {#
				mass.ext.quantile <- mass.ext.quantile / 2#
				ext.casualty <- apply(trait.sel, 2, function(x) {#
					intersect(which(x >= quantile(x, mass.ext.quantile)), which(x <= quantile(x, (1-mass.ext.quantile))))#
					}#
				)#
			}#
			length.strict <- length(open.edges[ext.casualty])#
			extinct.check <- floor(mass.ext.severity * length(open.edges))#
			if (length(ext.casualty) > extinct.check) {#
				ext.casualty <- sample(ext.casualty, floor(mass.ext.severity * length(open.edges)))#
				}#
			length.not.strict <- length(open.edges[-ext.casualty])#
			vector.of.probs <- c(rep(1, length.strict), rep(chance.of.random, length.not.strict))#
			vector.of.probs <- vector.of.probs / sum(vector.of.probs)#
			if (chance.of.random <= 1e-8) {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				ext.casualty <- sample(c(ext.casualty, non.casualty), length.strict, prob=vector.of.probs)#
			} else {#
				rand.ext <- 1:length(vector.of.probs)#
				non.casualty <- rand.ext[-ext.casualty]#
				to.go <- floor(mass.ext.severity * length(open.edges))#
				ext.casualty <- sample(c(ext.casualty, non.casualty), to.go, prob=vector.of.probs)	#
			}#
			start.edge[open.edges[ext.casualty], 2] <- 0	#
			mass.ext.occ <- FALSE#
			mass.ext.time <- total.time#
			open.edges <- which(is.na(start.edge[,2]))#
			tips <- length(which(start.edge[ ,2] == 0))#
			n.tips.t <- tips#
			if ((n.tips.t * 2 - 2) == dim(start.edge)[1]) tree.alive <- FALSE			#
		}#
	}#
	N <- length(open.edges)#
	waiting.time <- rexp(1, N * (lambda + mu))#
	total.time <- total.time + waiting.time#
	edge.lengths[open.edges] <- edge.lengths[open.edges] + waiting.time	#
	branch.value.list[open.edges] <- lapply(branch.value.list[open.edges], function(branch.vals) {#
	last.time <- branch.vals[dim(branch.vals)[1], ]#
	withinBounds <- FALSE#
	while (withinBounds == FALSE) {#
		branch.vals.temp <- last.time + mvrnorm(n=1, mu=rep(0, n.characters), Sigma= waiting.time * bm.rates)#
		if (all(c(branch.vals.temp <= upperBound, branch.vals.temp >= lowerBound))) withinBounds <- TRUE#
			}#
	rbind(branch.vals, branch.vals.temp)#
		}#
	)	#
	time.list[open.edges] <- lapply(time.list[open.edges], function(x) c(x, total.time))	#
	# # remove zero length edges#
	# zero.length <- which(sapply(branch.value.list, function(x) dim(x)[1] == 1))#
	# if (length(zero.length) == 2) {#
		# start.edge[,2][match(start.edge[zero.length, 1][1], start.edge[,2])] <- 0#
		# start.edge <- start.edge[-zero.length, ]#
		# branch.value.list <- branch.value.list[-zero.length]#
		# edge.lengths <- edge.lengths[-zero.length]#
		# }#
	# make trait list conform to edge list object#
	trait.list <-lapply(1:n.characters, function(all.traits) {#
		anc.state <- t(sapply(branch.value.list, function(x) {#
			x.one <- x[1, all.traits]#
			x.two <- dim(x)[1]#
			c(x.one, x[x.two, all.traits])#
			})#
		)#
		colnames(anc.state) <- c("internal", "external")#
		anc.state#
		}#
	)#
	# test the tree is a true phylogeny#
	tips <- c(which(start.edge[ ,2] == 0), which(is.na(start.edge[,2])))#
	n.tips <- length(tips)#
	edge.dim <- dim(start.edge)[1]#
	if (((n.tips * 2 - 2) != edge.dim)) warning("this is not a tree")#
#
	# test and correct for missing edge values in 'start.edge'#
	continuous.seq <- match(seq(1:max(start.edge, na.rm=T)), c(start.edge))#
	cont.na <- which(is.na(c(continuous.seq)))#
	if (length(cont.na) > 0) {#
		edge.one <- which(start.edge[,1] > cont.na)#
		start.edge[edge.one, 1] <- start.edge[edge.one, 1] - 1#
		edge.two <- which(start.edge[,2] > cont.na)#
		start.edge[edge.two, 2] <- start.edge[edge.two, 2] - 1#
	}#
	# build ape tree#
	start.edge[,1] <- start.edge[,1] + n.tips#
	start.edge[-tips,2] <- start.edge[-tips,2] + n.tips#
	start.edge[tips, 2] <- 1:n.tips#
	start.edge[which(start.edge[,2] <= n.tips), 2] <- 1:n.tips#
	orig.outer <- start.edge[which(start.edge[,2] > n.tips), 2]#
	start.edge[which(start.edge[,2] > n.tips), 2] <- sort(orig.outer)#
	start.edge.orig.2 <- start.edge[,1]#
	for(p in 1:length(sort(orig.outer))) start.edge[,1][which(orig.outer[p] == start.edge.orig.2 )] <- sort(orig.outer)[p]#
	phy <- list(edge=start.edge, tip.label=paste0("t", 1:n.tips), edge.length=edge.lengths,  Nnode=n.tips-1)#
	class(phy) <- "phylo"#
	re.order <- reorder(phy, order = "cladewise", index.only = TRUE)#
	tree.object <- list()#
	tree.object$phy <- read.tree(text=write.tree(phy))#
	tree.object$root.state <- root.state#
	if(return.trait.matrix) tree.object$trait.matrix <- lapply(trait.list, function(x) x[re.order,])#
	if(return.branch.value.list) tree.object$branch.value.list.out <- branch.value.list[re.order]#
	if(return.time.list) tree.object$time.list.out <- time.list[re.order]#
	time.ltt <- unlist(lapply(time.list[re.order], function(xx) xx[-1]))#
    tab.time.ltt <- table(signif(time.ltt, 10))#
    ltt.times <- as.numeric(names(tab.time.ltt))#
    tot.ln <- length(ltt.times)#
    re.scale <- diff(c(1, min(as.numeric(tab.time.ltt))))#
    ltt.measure <- cbind(node.times = c(0, ltt.times), lineages = c(0, as.numeric(tab.time.ltt)))#
	tree.object$ltt <- ltt.measure#
	unlist.time <- unlist(time.list[re.order])#
	trait.ltt <- lapply(signif(ltt.measure[,1]), function(t.l) {#
		time.point.node <- which(signif(unlist.time) == t.l)#
		traits.out <- c()#
		for(q in 1:n.characters) {#
			unlist.traits <- unlist(sapply(branch.value.list[re.order], function(x) x[,q]))#
			traits.out <- cbind(traits.out, unique(unlist.traits[time.point.node]))#
			}#
		traits.out#
		}#
	)#
	tree.object$node.traits <- trait.ltt#
	if (mass.ext.occ.input) tree.object$mass.ext.time <- mass.ext.time#
	return(tree.object)#
}
tr <- build.tree.tips(mass.ext.occ=F)
tr[[1]]
tr <- build.tree.tips(mass.ext.occ=T)
tr[[1]]
tr <- build.tree.tips(mass.ext.occ=T, mass.ext.tips=100, mass.ext.severity=0.75)
tr[[1]]
